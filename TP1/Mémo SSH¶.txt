M√©mo SSH¬∂
Allez, vous venez l√† pour voir les commandes √† use, je vous mets des beaux blocs de code comme on aime.

Si t'aimes pas, c'est que c'est l'heure d'arr√™ter de use ChatGPT hein.

Ici on ne parle que de SSH client. Je ne mentionne pas une seule fois une commande ou une configuration serveur.
C'est donc uniquement sur votre PC que vous faites tout √ßa √† priori pour nos TPs.

Aussi, on d√©taillera quedal du fonctionnement de SSH : je me contente ici d'en documenter l'utilisation, pour nous, les utilisateurs. üêà

Connexion simple¬∂
# Commande SSH basique : connexion √† 10.1.1.1 en tant que toto
ssh toto@10.1.1.1

# Ptite variation : si on veut pr√©ciser le port auquel on se connecte (22/tcp si on pr√©cise pas)
# On indique 2222/tcp ici (toujours TCP par d√©faut avec SSH)
ssh toto@10.1.1.1 -p 2222
Gestion de cl√©s¬∂
Je rappelle au cas o√π : l'utilisation de cl√© c'est bien plus fort niveau s√©cu que de reposer sur un mot de passer pour vous identifier sur un serveur distant !

SSH auth via keys

# G√©n√©ration d'une paire de cl√©s
ssh-keygen

# On peut pr√©ciser quel algo on souhaite utiliser avec -t
ssh-keygen -t rsa

# Et on peut aussi pr√©ciser la longueur de la cl√© avec -b
ssh-keygen -t rsa -b 4096

# Par d√©faut, les cl√©s s'enregistrent dans un chemin standard : ~/.ssh
ls -l ~/.ssh
.rw-------  464 it4 it4  2 Sep 16:39 id_rsa
.rw-r--r--   99 it4 it4  2 Sep 16:39 id_rsa.pub
Tip
Un mot de passe (passphrase) est demand√© lorsque vous g√©n√©rez une cl√©. Si vous laissez vide, la cl√© ne sera pas prot√©g√©e par un mot de passe.
L'id√©e c'est que la cl√© priv√©e devient tr√®s pr√©cieuse car elle permet de se connecter √† tous les serveurs o√π t'as pos√© ta cl√© publique, c'est giga sensible.
Donc un vilain hacker, il veut voler des cl√©s priv√©es.
Suffit que je vole le contenu de ton disque, et c'est cram√©.
Pour √©viter √ßa : on prot√®ge la cl√© avec un password. Elle est inutilisable si on ne la d√©bloque pas avec le password d√©fini √† la g√©n√©ration.
Concr√®tement, la cl√© priv√©e est chiffr√©e quand on d√©fini une passphrase.

Private Keys

# On peut par la suite d√©poser la cl√© publique au bon endroit avec une commande d√©di√©e
# Cette commande va se connecter en SSH en tant que toto sur 10.1.1.1, puis poser la cl√© publique au bon endroit sur la machine distante
ssh-copy-id toto@10.1.1.1

# Vous pouvez ensuite vous connecter sans saisr de password :
ssh toto@10.1.1.1

# Si ta cl√© n'a pas un nom standard et/ou n'est pas dans un endroit standard, il faudra pr√©ciser son chemin avec -i
ssh -i /home/toto/dossier_chelou/ma_super_cl√© toto@10.1.1.1
Info
Je rappelle que le caract√®re ~ fait r√©f√©rence au r√©pertoire personne de l'utilisateur qui tape la commande.
Donc sous Linux, si t'es connect√© avec toto, √©crire ~ c'est comme √©crire /home/toto.
Sous Windows, √ßa correspondra donc √† C:/Users/toto. Sous MacOS j'crois c'est /Users/toto non ?

Fichier de config SSH client¬∂
# Vous pouvez vous cr√©er un fichier de config SSH pour taper des commandes moins chiantes
# Prenons la commande chiante et longue suivante :
ssh -p 2222 -i ~/.ssh/cloud_tp toto@10.1.1.1

# Vous la trouvez pas chiante ? Ok. Je rajoute une option histoire de vous convaincre.
# Prenons la commande chiante et longue suivante :
ssh -p 2222 -i ~/.ssh/cloud_tp -o StrictHostKeyChecking=no toto@10.1.1.1

# Au lieu de taper ou copy/paste cette folie, on peut cr√©er un fichier de config SSH client
# Le fichier DOIT √™tre dans le chemin standard : ~/.ssh/config
cat ~/.ssh/config

Host yolo
  HostName 10.1.1.1
  User toto
  Port 2222
  IdentityFile /home/toto/.ssh/cloud_tp
  StrictHostKeyChecking no

# On peut ensuite se connecter en tapant :
ssh yolo

# D'un coup, c'est moins chiant nan ?
Note
Vous pouvez √©videmment mettre autant de Host que vous voulez dans ce fichier.
Il supporte m√™me les wildcards avec le caract√®re *.
Genre Host *.meo.com indique une conf pour tous les h√¥tes qui se terminent par .meo.com.
Ou encore 10.1.1.* pour une conf qui concernent tous les h√¥tes dont l'IP commence par 10.1.1..

Agent SSH¬∂
# D√©marrer un agent SSH en fond
# Sur Windows faut d√©marrer un service
# Sur Linux on peut lancer un :
eval $(ssh-agent)

# Ajouter une cl√© √† l'agent qui run en fond (peu importe l'OS)
ssh-add ~/.ssh/cloud_tp

# Un password sera demand√© si la cl√© a √©t√© prot√©g√©e par un password √† la g√©n√©ration

# Toutes les commandes suivantes utiliseront les cl√©s ajout√©es pour se co
ssh yolo
# Me connecte sans aucun prompt (aucun password demand√©) m√™me si la cl√© est prot√©g√©e par un password (saisi lors de l'ajout √† l'agent)

# On peut faire suivre l'agent avec -A, il nous suivra sur la machine o√π on se connecte
ssh -A yolo

# Depuis la machine yolo, on peut faire une connexion SSH vers une autre machine, comme si on avait notre cl√© priv√©e sur la machine yolo
[it4@yolo]$ ssh toto@10.1.1.2
Note
Le -A se note ForwardAgent si on le d√©finit dans le fichier config.

Rebond SSH¬∂
Ca arrive souvent que quand on g√®re plusieurs machines, on en expose qu'une seule en SSH, pour limiter la surface d'attaque et les risques.

Note
C'est un peu une des r√®gles de s√©curit√© infrastructure ultra √©l√©mentaire : on expose que le strict minimum.
On diminue toujours au max la surface d'attaque, le nombre de machins expos√©s, et donc, on att√©nue au max les risques.

Sauf que c'est chiant pour se connecter aux autres machines : je dois genre me connecter √† la premi√®re, ptet avec un -A, puis taper une deuuuuxi√®me commande pour me connecter √† ma vraie destination.

Trop chiant üêà

Rebond SSH √† la rescousse. Supposons :

j'ai d√©pos√© ma cl√© publique sur une machine A (je peux donc m'y co sans password)
j'ai aussi d√©pos√© ma cl√© publique sur une machine B (je peux donc m'y co sans password)
seule la machine A est expos√©e
je peux me co √† la machine A, puis, de l√†, √† la machine B
On parle donc par exemple de :

# D'abord, depuis notre PC
ssh -A toto@10.1.1.1
# Avec le -A pour faire suivre mon agent

# Puis, depuis la machine 10.1.1.1
ssh toto@10.1.1.2
# Ca marche sans password : j'ai fait suivre mon agent

# Et encore on fait avec un cas simple o√π y'a pas d'options particuli√®res
On peut remplacer ces deux commandes en faisant une unique commande qui utilise un rebond SSH :

on utilise l'option -J
on indique qu'on veut se connecter √† la machine B en "rebondissant" sur la machine A
ssh -A -J toto@10.1.1.1 toto@10.1.1.2
Note
Le -J se note ProxyJump si on le d√©finit dans le fichier config.

Everything¬∂
Ca devient tr√®s tr√®√®√®√®s pratique et puissant quand on combine tout ce qu'on a vu.

Supposons qu'on doive se connecter √† une machine B en passant par une machine A, comme √ßa :

# Connexion √† la machine A
ssh -p 2222 -A toto@10.1.1.1

# Puis, de l√†, connexion √† la machine B
ssh -p 3333 meow@10.1.1.2
Rempla√ßons tout ce caca par un fichier config clean :

Host machineA
    HostName 10.1.1.1
    User toto
    Port 2222
    ForwardAgent yes

Host machineB
    HostName 10.1.1.2
    User meow
    Port 3333
    ProxyJump machineA
On peut alors se connecter √† la machine B, directement depuis notre poste, en tapant :

ssh machineB
Success
SI C'EST PAS SEXY ALORS JE SAIS PAS MOI. üêà